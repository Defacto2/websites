<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML//EN">
<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="GENERATOR" content="Microsoft FrontPage 2.0">
<title>Untuchables Training Tutorial</title>
</head>

<body bgcolor="#400080" text="#FFFFFF" link="#00FFFF"
vlink="#316F6A">

<p align="center"><font size="7"><strong>THE UNTUCHABLES</strong></font></p>

<p align="center">PRESENT : </p>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td>Training Tutorial for the PC. By Dr. Detergent /
        UNT'93 </td>
    </tr>
</table>
</center></div>

<p align="center"><font size="2">Converted to HTML by Jammer/HBD</font></p>

<p><font size="4"><u>Table of contents:</u></font><br>
Section:</p>

<p>1 - <a href="#s1">Introduction.</a><br>
2 - <a href="#s2">Before starting.</a><br>
3 - <a href="#s3">Debugging through.</a><br>
4 - <a href="#s4">Different file compression techniques.</a><br>
5 - <a href="#s5">Once inside the game's code.</a><br>
6 - <a href="#s6">Most common training byte structure
composition.</a><br>
7 - <a href="#s7">Searching for the most common training byte
structure composition.</a><br>
8 - <a href="#s8">Problems finding the most common training byte
structure composition.</a><br>
9 - <a href="#s9">Setting the break points.</a><br>
10 - <a href="#s10">Once you have found the trainer data.</a><br>
11 - <a href="#s11">Making a &quot;hard-cheat&quot;</a><br>
12a - <a href="#s12a">Generic trainer interfacing routine.</a><br>
12b - <a href="#s12b">Interfacing to the game's keyboard routine.</a><br>
12c - <a href="#s12c">Finding the game's keyboard handling
routine.</a><br>
12d - <a href="#s12d">Prince of Persia II keyboard handling
routine listing.</a><br>
13 - <a href="#s13">Handling different DS values.</a><br>
14 - <a href="#s14">Writing the trainer loader or TSR code.</a><br>
15 - <a href="#s15">Generic TSR self-removal routine.</a><br>
16a - <a href="#s16a">Generic trainer code interfacing routine.</a><br>
16b - <a href="#s16b">Prince of Persia II interactive trainer
interfacing routine.</a><br>
16c - <a href="#s16c">Finding the runtime CS:IP of the keyboard
handling routine.</a><br>
16d - <a href="#s16d">Comparing the program's current IP.</a><br>
16e - <a href="#s16e">Interfacing with different keyboard
handling routines.</a><br>
17 - <a href="#s17">Fox Ranger Interactive 9 option trainer
routine listing.</a><br>
18 - <a href="#s18">Legend of Myra Interactive 10 option trainer
routine listing.</a><br>
19 - <a href="#s19">Interactive TSR/loader trainer examples.</a><br>
20 - <a href="#s20">Summary.</a></p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s1">Section 1</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Introduction:</u></font></p>

<p>Every game player has at some point during gameplay, wished
that he/she had more lives/energy/weapons/time etc - just to be
able to finish that level or see the game's ending for that
matter. </p>

<p>Have you ever played a game for months, each time getting
better and better, finally you make it to the last level only to
find that the monster at the end is impossible to kill even with
all your past experience?</p>

<p>Ever play a game for 5 hours and finally get to the last level
- just before the ending intro, and suddenly get killed by some
small rodent - and have to restart all over?! </p>

<p>Well I am sure you have experienced the above. This is why
hackers/crackers developed a kind of &quot;Training Aid&quot; if
you want to call it that. The terminology training means to bring
an individual to a higher degree of success through practice. In
computer terms, the phrase training was developed by hackers on
the C-64/Amiga.</p>

<p>Whenever someone played a game and couldn't finish it, when
using a trainer, the person could train on the last level and
become proficient in the skills required in mastering that level,
then he could turn off the trainer and try his newly acquired
skills in the real thing.</p>

<p>The term CHEAT as some people refer to, is not a good
description of what a real trainer actually is. Most trainers are
interactive, meaning that they let you toggle certain things
on/off or select different items during game play - a cheat
however, mostly gives you straight away unlimited lives/items etc
and rarely let's you &quot;train&quot; while playing the game. </p>

<p>Training games has been going on for ages. It started back as
far as the C-64, maybe even further. It has seen it's days on all
the computers that one can use to play games. </p>

<p>Training was revolutionized mostly on the Amiga computer. The
games for the Amiga are outstanding, and so are the trainers. I
have seen trainers for some games that I thought were the game
itself. </p>

<p>On the PC, training started the day that games were designed
for it. Since it's early days, training on the PC has
revolutionized from small &quot;cheats/character editors&quot; to
todays interactive, multi-functional, user defined,
mega-trainers. </p>

<p>This Training Tutorial was written for those who always
wondered how one makes trainers on the PC, and it portrays this
art to you. Never the less, it all depends on you - how good you
are with understanding the assembly language and programming. </p>

<p>I'm confident that your average ASM programmer or hacker will
find the information herein helpful and useful. </p>

<p>Through my many years of training on the PC, and after
developing more than 285+ trainers/cracks, I have learned lots of
different tricks and methods that I will reveal to you in this
training tutorial.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s2">Section 2</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Before starting:</u></font></p>

<p>First, you must have a general knowledge of debugging software
and ASM programming. Before you begin to even think about
training a certain game, ask yourself the following questions : </p>

<p>1) Has a trainer already been released for that game -
sometimes you spend hours training a game only to find out just
before you are about to spread it world-wide, that there already
is a trainer out for it - and it is even better then yours!</p>

<p>2) Is the game trainable - if yes, what items/things can it be
trained for? You will be surprised how many requests I had to
make trainers for games that are not trainable - like text
adventure games! - so make sure that at least something in your
game is trainable.</p>

<p>3) Is it worth it - are you going to spend 5 hours training a
shareware pacman-type game?! </p>

<p>4) Can you handle the code - do you think you can get by the
game's nasty encryption/anti-debugging routines or
script-compiler type code?</p>

<p>5) Will you be able to make the trainer - do you think that
you can write the code that will integrate your trainer with the
game and be able to modify the necessary data? Sure you can find
the necessary data to alter in the program, but can you write up
a TSR or a loader that can integrate itself to the game's code
and modify the necessary data locations? </p>

<p>Once you have asked yourself the above questions, and feel
confident about your answers, then proceed to section 3.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s3">Section 3</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Debugging Through:</u></font></p>

<p>This section deals with debugging the game program. It will
outline the various debuggers you can use, various compression
methods and how to get through them. </p>

<p>Before we even begin - what debugger are you going to use? Ok,
I will make this question simpler - if you have a 386+ CPU, what
debugger are you going to use?</p>

<p>That's right - <strong>SOFT-ICE</strong> 2.52+!. This is the
best debugger. Below are some other debuggers listed in priority
order, you might consider using: </p>

<p>Turbo Debugger 386+<br>
Code View 386+ <br>
Any other 386+ virtual mode debugger<br>
Turbo Debugger 286- <br>
Code View 286- <br>
Periscope <br>
Debug.exe </p>

<p>Ever since I have been cracking/training games, I have never
seen a more powerful or complete debugger than Soft-Ice. Now
don't think that you have to have Soft-Ice to train, I have used
debug on my XT / CGA to train some complex VGA games, - not even
being able to see the screen, and having the trainer tested on my
friends VGA, back in the old days. </p>

<p>You can train a game with ANY debugger and still make a good
trainer at that. But using soft-ice will speed up the process
extremely and yield the best results. That's why in some examples
here I will use Soft-Ice as the main debugger. </p>

<p>Ok, so you are not lame, and do have a 386+ chip, vga,
extended memory, and soft-ice loaded. Now you have your game
neatly installed and ready to be debugged and trained. </p>

<p>Now you have to find the start-up file. This is the EXE or COM
loader that starts the game. This is where you will find the
necessary data to train your game - 95% of the time. Remember
that the EXE/COM loader can load up an OVR or a BIN file, so if
the start-up file is really small like 5 k, then you know for
sure it's going to load in some overlay code. </p>

<p>Ok, so use soft-ice's LDR.EXE to load up the start-up file (or
debug the file with another debugger). Now unassemble the first
instructions and study the code. Try to determine if the code is
compressed by something like LZEXE, PKLITE, DIET, EXEPACK,
Secure-Wrap or some other COM/EXE file compressor. </p>

<p>You can skip this step if you know how to write a loader or a
TSR. Otherwise, this step gives you an idea if you can or can't
train the program - if you can't write a TSR or loader, then how
can you interface and change the necessary data in the game if
it's encrypted? (Even if you knew at what location the lives
decrementing instruction etc is, searching the EXE/COM file with
a hex editor to do a hard-train will yield no results</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s4">Section 4</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Different file compression techniques:</u></font></p>

<p>Here are some examples of the different compression techniques
used on COM/EXE files:</p>
<div align="left">

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td>PKLITE 1.20 (COM File)</td>
    </tr>
</table>
</div>

<p><font face="Courier">0100 B8BDE2 MOV AX,E2BD<br>
0103 BA2284 MOV DX,8422<br>
0106 3BC4 CMP AX,SP<br>
0108 7367 JNB 0171<br>
010A 8BC4 MOV AX,SP<br>
010C 2D4403 SUB AX,0344<br>
010F 25F0FF AND AX,FFF0<br>
0112 8BF8 MOV DI,AX<br>
0114 B9A200 MOV CX,00A2<br>
0117 BE7C01 MOV SI,017C<br>
011A FC CLD <br>
011B F3 REPZ <br>
011C A5 MOVSW <br>
011D 8BD8 MOV BX,AX<br>
011F B104 MOV CL,04<br>
0121 D3EB SHR BX,CL<br>
0123 8CD9 MOV CX,DS<br>
0125 03D9 ADD BX,CX<br>
0127 53 PUSH BX <br>
0128 33DB XOR BX,BX<br>
012A 53 PUSH BX <br>
012B CB RETF ;*** RETF Instruction ***<br>
012C 0C01 OR AL,01<br>
012E 50 PUSH AX <br>
012F 4B DEC BX <br>
0130 4C DEC SP <br>
0134 20436F AND [BP+DI+6F],AL<br>
0137 7072 JO 01AB<br>
0139 2E CS: </font></p>

<p>* Note the RETF instruction at 012B. This instruction when
encountered in the beginning of the code like this, nearly always
gives an indication that the file is compressed.</p>

<p>(The code after 012B is just compressed garbage. When you see
garbage after a RETF instruction, found in the beginning of the
code, than you are nearly sure that the file is compressed by
something)</p>
<div align="left">

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td>LZEXE 0.91 (EXE File)</td>
    </tr>
</table>
</div>

<p><font face="Courier">000E 06 PUSH ES <br>
000F 0E PUSH CS <br>
0010 1F POP DS <br>
0011 8B0E0C00 MOV CX,[000C]<br>
0015 8BF1 MOV SI,CX<br>
0017 4E DEC SI <br>
0018 89F7 MOV DI,SI<br>
001A 8CDB MOV BX,DS<br>
001C 031E0A00 ADD BX,[000A]<br>
0020 8EC3 MOV ES,BX<br>
0022 FD STD <br>
0023 F3 REPZ <br>
0024 A4 MOVSB <br>
0025 53 PUSH BX <br>
0026 B82B00 MOV AX,002B<br>
0029 50 PUSH AX <br>
002A CB RETF ;*** RETF instruction ***<br>
002B 2E CS: <br>
002C 8B2E0800 MOV BP,[0008]</font></p>

<p>* Note the RETF instruction at 002A.</p>
<div align="left">

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td>DIET 1.10a (COM File)</td>
    </tr>
</table>
</div>

<p><font face="Courier">0100 BE5409 MOV SI,0954<br>
0103 BFDC13 MOV DI,13DC<br>
0106 B91404 MOV CX,0414<br>
0109 3BFC CMP DI,SP<br>
010B 7204 JB 0111<br>
010D B44C MOV AH,4C<br>
010F CD21 INT 21<br>
0111 FD STD<br>
0112 F3 REPZ<br>
0113 A5 MOVSW<br>
0114 FC CLD<br>
0115 8BF7 MOV SI,DI<br>
0117 BF0001 MOV DI,0100<br>
011A AD LODSW<br>
011B AD LODSW<br>
011C 8BE8 MOV BP,AX<br>
011E B210 MOV DL,10<br>
0120 E96D12 JMP 1390<br>
0123 64 DB 64 \<br>
0124 6C DB 6C / Garbage from here onwards.</font></p>
<div align="left">

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td>EXEPACK ??? (EXE File)</td>
    </tr>
</table>
</div>

<p><font face="Courier">0010 8BE8 MOV BP,AX<br>
0012 8CC0 MOV AX,ES<br>
0014 051000 ADD AX,0010<br>
0017 0E PUSH CS<br>
0018 1F POP DS<br>
0019 A30400 MOV [0004],AX<br>
001C 03060C00 ADD AX,[000C]<br>
0020 8EC0 MOV ES,AX<br>
0022 8B0E0600 MOV CX,[0006]<br>
0026 8BF9 MOV DI,CX<br>
0028 4F DEC DI<br>
0029 8BF7 MOV SI,DI<br>
002B FD STD<br>
002C F3 REPZ<br>
002D A4 MOVSB<br>
002E 50 PUSH AX<br>
002F B83400 MOV AX,0034<br>
0032 50 PUSH AX<br>
0033 CB RETF ;*** RETF instruction ***<br>
0034 8CC3 MOV BX,ES<br>
0036 8CD8 MOV AX,DS<br>
0038 48 DEC AX<br>
0039 8ED8 MOV DS,AX</font></p>

<p>* Note the RETF instruction at 0033.</p>
<div align="left">

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td>Some other compression method (EXE File)</td>
    </tr>
</table>
</div>

<p><font face="Courier">000C 8CD3 MOV BX,SS<br>
000E 8EC3 MOV ES,BX<br>
0010 8CCA MOV DX,CS<br>
0012 8EDA MOV DS,DX<br>
0014 8B0E0800 MOV CX,[0008]<br>
0018 8BF1 MOV SI,CX<br>
001A 83EE02 SUB SI,+02<br>
001D 8BFE MOV DI,SI<br>
001F D1E9 SHR CX,1<br>
0021 FD STD<br>
0022 F3 REPZ<br>
0023 A5 MOVSW<br>
0024 53 PUSH BX<br>
0025 B82E00 MOV AX,002E<br>
0028 50 PUSH AX<br>
0029 8B2E0A00 MOV BP,[000A]<br>
002D CB RETF ;*** RETF instruction ***<br>
002E B80010 MOV AX,1000<br>
0031 3BC5 CMP AX,BP<br>
0033 7602 JBE 0037<br>
0035 8BC5 MOV AX,BP<br>
0037 2BE8 SUB BP,AX<br>
0039 2BD0 SUB DX,AX<br>
003B 2BD8 SUB BX,AX<br>
003D 8EDA MOV DS,DX<br>
003F 8EC3 MOV ES,BX<br>
0041 B103 MOV CL,03<br>
0043 D3E0 SHL AX,CL<br>
0045 8BC8 MOV CX,AX<br>
0047 D1E0 SHL AX,1<br>
0049 48 DEC AX<br>
004A 48 DEC AX<br>
004B 8BF0 MOV SI,AX<br>
004D 8BF8 MOV DI,AX<br>
004F F3 REPZ<br>
0050 A5 MOVSW<br>
0051 0BED OR BP,BP<br>
0053 75D9 JNZ 002E<br>
0055 FC CLD<br>
0056 8EC2 MOV ES,DX<br>
0058 8EDB MOV DS,BX</font></p>

<p>* Note the RETF instruction at 002D.</p>

<p>So basically you get the picture. Now to trace through the
code to the part where the whole program uncompresses itself is
really easy.</p>

<p>First, always remember to TRACE or PROCEED through any RETF
instruction. In most cases there is only one RETF instruction to
trace or proceed through. Then once you traced or proceeded
through it, you will be either at CS:0000 or somewhere else. The
next step is simple too - Just unassemble the code until you find
the following instruction:</p>

<p><font face="Courier">CS:<br>
JMP FAR [BX]</font></p>

<p>Once found, simply go to the address containing CS:, then
trace or proceed through. Now you should have the clean
uncompressed code. If you did not find the above instruction,
then try looking for another RETF instruction. Once found go to
it and trace or proceed through and you should have the clean
uncompressed code.</p>

<p>Remember some files may be compressed with 2 compression
programs (for &quot;added protection&quot; as software authors
think!). If so, simply perform the above steps twice.</p>

<p>Finding the part of the program that the file starts up at is
helpful in 2 ways :</p>

<p>1) You are sure that the program didn't start executing any
instructions yet - like moving lives/energy etc variables into
memory.</p>

<p>2) You can note the CS, DS, or any other memory variables so
that when you do write up a TSR or a loader, you will be able to
interface it easier.</p>

<p><font size="3"><strong><u>Note:</u></strong></font></p>

<p>(You need to know the program's current CS,DS upon startup, if
you are going to write the generic tsr or loader trainer
interfacing routine as outlined in <a href="#s12a">section 12a</a>).</p>

<p>If you don't care about getting to the program's very
beginning, and just want to get through the uncompression as fast
as possible, then if using soft-ice, set a break point on INT 21
- it will break in when the program does a DOS VER check, a
memory allocation call or any other function using INT 21. All
games and most programs have INT 21's present in their program
code.</p>

<p>Some of you might even want to start the game, get the game
fully running, and then break into the debugger. I use this
method. Doing this has some good points and some bad points. The
good points might be that the CS,DS values are already redefined
and you more or less see where the program keeps it's data
values. Some bad points might be that you have skipped past the
value-initialization routine (of the lives etc). If you are
unexperienced, then I recommend that you do not use this method.</p>

<p>Some software programmers put anti-debugging routines in their
software code to deter hackers/crackers from cracking their
software. This works to the trainer's disadvantage - sometimes.
I'm not going to describe the various anti-debugging methods and
their antidotes in this training tutorial - learn all about it in
the upcoming &quot;Cracking on the PC - THE mega tutorial!&quot;</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s5">Section 5</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Once inside the game's code:</u></font></p>

<p>Ok, so you are in the program now. What now? A lot of people
have asked me what's harder to do - crack a game or make a
trainer for it. Well it depends really. Some games can be cracked
in 5 minutes, while making a good trainer can take 8+ hours. But
in general I think making trainers is a bit more difficult than
cracking. Mostly because making a trainer will always consume
more time - at LEAST 1 hour to find/make/write/package the
trainer.</p>

<p>Also, when cracking a game, you isolate the protection in a
certain area of the program, then focus all your attention on it
and crack it. When training a program, you are looking through
everything, everywhere, gathering all sorts of unnecessary data
before finding the right bytes, let alone understanding the game
code operation.</p>

<p>But once again, there are short cuts to everything. This is
why training might be easier that cracking after all. Every
program uses more or less the same technique to
decrement/increment your lives/energy/ammo/inventory items, etc.</p>

<p>Through my years of training, I have narrowed it down to the
most common byte structure composition, as outlined in section 6.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s6">Section 6</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Most common training byte structure
composition:</u></font></p>

<p><em><strong>DECREMENTING</strong></em></p>

<p>Decrementing or subtracting means to decrease a certain thing.
The game uses various decrementing instructions to decrement (or
subtract if you like) your
lives/energy/time/ammo/weapons/inventory items etc. </p>

<p>The following is a list of the most common decrementing
instructions that games use: </p>

<p><font face="Courier">DEC </font><font size="3" face="Courier">WORD</font><font
face="Courier"> PTR [1234] - ****<br>
In HEX : FF 0E 34 12</font></p>

<p><font face="Courier">DEC BYTE PTR [1234] - ****<br>
In HEX : FE 0E 34 12</font></p>

<p><font face="Courier">SUB WORD PTR [1234],XX - **<br>
In HEX : 83 2E 34 12 XX</font></p>

<p><font face="Courier">SUB BYTE PTR [1234],XX - *<br>
In HEX : 80 2E 34 12 XX</font></p>

<p><font face="Courier">SUB [1234],AX - **<br>
In HEX : 29 06 34 12</font></p>

<p><font face="Courier">SUB [1234],DX - *<br>
In HEX : 29 16 34 12</font></p>

<p><em><strong>INCREMENTING</strong></em></p>

<p>Incrementing or adding means to add a value to a certain
thing. The game uses various incrementing instructions to
increment (or add if you like) your current
level/energy/time/ammo/weapons/inventory items etc. The following
is a list of the most common incrementing instructions that games
use:</p>

<p><font face="Courier">INC WORD PTR [1234] - ****<br>
In HEX : FF 06 34 12</font></p>

<p><font face="Courier">INC BYTE PTR [1234] - ****<br>
In HEX : FE 06 34 12</font></p>

<p><font face="Courier">ADD WORD PTR [1234],XX - ***<br>
In HEX : 83 06 34 12 XX</font></p>

<p><font face="Courier">ADD BYTE PTR [1234],XX - **<br>
In HEX : 80 06 34 12 XX</font></p>

<p><strong><u>Legend:</u></strong></p>

<p>**** - Very common - nearly 100% probability.<br>
*** - Common - about 70% probability.<br>
** - Likely - about 40% probability.<br>
* - Sometimes - about 10% probability.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s7">Section 7</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Searching for the most common training byte
structure composition:</u></font></p>

<p>By now you should be in the program viewing the uncompressed
code. Simply start searching for the above bytes - depending for
what you are looking for. For starting out, you should not be
concerned with searching for the incrementing or adding
instructions - these instructions are used for incrementing
levels in the game, or inventory, etc. Training for those options
is much harder at first, so stick to the decrementing
instructions. </p>

<p>So now start searching for the most common decrementing
instruction - mainly the DEC WORD PTR [XXXX]. I will use this
example because it's the most common decrementing instruction
that you will find. Obviously you can, and you should, search for
the other less common decrementing instructions too.</p>

<p>The following search example can be used to search for all the
decrementing and incrementing instructions.</p>

<p><strong><u>Example:</u></strong></p>

<p>S CS:0 L FFFF FF 0E (Works with most debuggers)</p>

<p><strong><u>Note:</u></strong></p>

<p>We only search for the first 2 bytes of the DEC/INC
instruction because the 3rd and 4th bytes contain the value of
the address where the DEC/INC is going to take place.</p>

<p>To make things simpler, let's assume that you are searching
for the above example (DEC WORD PTR [XXXX]). I will use this
example from now on. Remember, you can apply this example the
same way to search or process all the other DEC/INC instructions,
as outlined in <a href="#s6">section 6</a>.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s8">Section 8</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Problems finding the most common training
byte structure composition:</u></font></p>

<p>If you didn't find anything, or just a few DEC's that are not
related to anything, then it's because of the following :</p>

<p>1) You are looking in the wrong CS. Some games have many
different CS values. If the program's current CS is 1200, and you
search for the DEC bytes and find about 4, and then run the
program, break in again, and notice CS is 2245, and search for
those bytes again, you might find 30 or more, so make sure you
search all the possible CS values in the game.</p>

<p>It's hard to break in, just hoping to find the next CS value
in the game - if any. A good technique is to search like this: </p>

<p>Find the lowest CS value in the game, - eg: 0900.</p>

<p>Then search CS:0 l FFFF FF 0E <br>
Then search 2000:0 l FFFF FF 0E <br>
Then search 3000:0 l FFFF FF 0E<br>
Then search 4000:0 l ffff FF 0E </p>

<p>Etc - get it? If the CS is always high during the game, and
you never seem to be able to break in when it's lower, then start
the search at about 0800, and then proceed higher. </p>

<p>2) The second possibility (if you didn't find anything after
searching for all the listed decrementing instructions) is that
the game is using a different decrementing instruction. </p>

<p>3) The third possibility is that the game's code is a
script-compiler type code. You can forget about training this
type of game - even if you are an experienced trainer maker. But
if you can train it, then you belong to the TOP-GUN trainer
makers! </p>

<p>The Script-compiler type code is found in such games from
Sierra, Delphine Software, Lucas Arts and CVS. It is a
programming method which uses pre-defined scripts to run certain
program operations. Everything from producing the sound on the
sound blaster to drawing the graphics on the screen is done all
in the same program loop - using different scripts. Therefore
training, or even cracking this type of game is really a pain,
but never the less, can be done.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s9">Section 9</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Setting the break-points:</u></font></p>

<p>From the search, you should have found quite a few of those
decrementing instructions in the game's loader. If you are using
soft-ice, note the current CS and write it down. Then unassemble
that address, study the code and make sure it's a valid
decrement, then set a break point on execution (BPX in soft-ice)
for about the first 8 of the found DEC WORD PTR [XXXX]
instructions. </p>

<p>The reason for unassembling the found instructions first and
then putting a break point on execution - as with soft-ice, or a
CC, as with other debuggers, is because the bytes FF 0E can
represent any other code or data value in the program. When you
unassemble that address where the bytes FF 0E where found and
study the code, if you see that the prior or following
instructions are garbage or don't make sense, then don't bother
setting a break point on that address since it's not going to be
executed anyway. </p>

<p>If you are not using soft-ice, do the above but instead of
setting a break point on execution, replace the first byte of the
DEC instruction with CC - so it will look like this:</p>

<p><strong><u>Example:</u></strong></p>

<p>Original found instruction : FF 0E 34 12<br>
1st byte replaced by CC : CC 0E 34 12</p>

<p>This will put an INT 3 at the beginning of that instruction.
Your debugger should break on INT 3 when it executes that
instruction. Do this for about the first 8 of the found DEC WORD
PTR [XXXX] instructions.</p>

<p>Now why did we do the above? Well we want to see which one of
the decrementing instructions decrements the lives/energy/timer
etc values. So the next step is to run the program. </p>

<p>Get by the introduction screen, etc and start playing the
game. (If your debugger breaks in even before you get to the
game, then simply remove that break point on execution from that
address - if using soft-ice, or replace the CC value with FF.
This is done since that instruction won't have anything to do
with decrementing your lives/energy/timer etc in the game - since
the game has not even started yet.</p>

<p>Once your game starts, and the debugger breaks in right away -
simply run the program again. If the same thing happens more than
about 3 times, and it always happens at the same address, then
remove the break point on execution from that address - if using
soft-ice, or replace the CC value with FF. The reason for this is
because the game might be using that instruction to do something
else other than decrementing your lives/energy/timer etc. </p>

<p>The next step is to try and get killed, or use your gun and
waste a few bullets, or do something like that - to see if any
inventory options, gadgets, energy bars, life counters, etc, are
being decremented. If they are, you will suddenly find yourself
in the debugger. Suppose you just got shot and even before you
saw your energy bar decrease, the debugger broke in. The first
thing that you do is write down that address - CS:XXXX. Then see
what value is being decremented at that address.</p>

<p><strong><u>Example:</u></strong></p>

<p>The debugger broke in at 45C8:</p>

<p><font face="Courier">1170:45C7 RET<br>
1170:45C8 DEC WORD PTR [0320]</font></p>

<p>Now simply view what is at that address (There is no CS:, ES:,
or SS: above the 45C8 instruction, so you know the default is
DS:):</p>

<p>D DS:320 (Using soft-ice, or use your debugger's dump command)</p>

<p>If you energy bar has for example 6 energy bars, and the value
at DS:0320 is 06, then you know you could very well have found
the address where the game stores your current energy value. </p>

<p>Now the next step is to check if that address is indeed the
current energy value storage address. Simply enter FF at DS:320
and then run the game again - notice anything different - more
energy bars? If so, you found it. If not, then maybe you still
found it, but there is another routine that updates the screen
with the current energy value. </p>

<p>So the next step is to NOP out that DEC instruction at that
address. But instead of doing that, simply replace the first 2
bytes of the DEC instruction (FF 0E) with EB 02 - thus jumping to
the next instruction. This is useful if you ever want to restore
that DEC instruction back - all you have to do is replace EB 02
with FF 0E. </p>

<p>If you NOP it out completely, not only do you have to put NOP
4 times, but you are erasing the address value of the DEC
instruction so unless you wrote down the address, you will have
to restart the program to restore back that instruction. </p>

<p>Ok, so you replaced the FF 0E with EB 02. Now run the game and
notice if some things are different - does the timer still go
down, or are the enemies still moving etc. Now get your energy to
go down. If you notice it go down, keep on getting hit until the
whole energy bar declines. If it does, and you are still alive,
then the game has 2 separate routines for storing and displaying
the energy bar. (Maybe another DEC instruction, which you have
not yet processed, is responsible for this).</p>

<p>If you died, then try something else now. Try to waste some
bullets/inventory items etc. If they all decrement and nothing is
different in the game, than that DEC instruction does something
else in the game.</p>

<p>Repeat the search command, as outlined in <a href="#s7">section
7</a>, and process the next 8 DEC instructions. Do this until you
have gone through them all. You should find at least some
decrementing instructions which decrease something like the
energy/lives/timer/enemy energy/inventory etc. If not, then
search for the next most common decrementing string, mainly the
FE 0E - DEC BYTE PTR [XXXX] </p>

<p>If you don't find anything there, proceed again with the next
most common decrementing string - until you find something. If
you still don't seem to be able to find anything worthwhile, then
refer to <a href="#s8">section 8</a>.</p>

<p><strong><u>Note:</u></strong></p>

<p>The code for some new games is written in a way that whenever
you set a break point on a certain address, the debugger won't
break there. Instead it will produce an error, or simply will
skip over that break point and continue running the program as if
nothing happened.</p>

<p>This is especially noticeable when using soft-ice's BPX
command. So if you really think that you have found the right
DEC/INC instruction, but soft-ice does not break in, then use the
same method of putting a break point as for the other debuggers -
by putting a EB 02 there at that address. Now see if any changes
occur in the game play.</p>

<p>What I sometimes noticed when debugging this type of game is
that after I set a break point on a certain dec instruction, run
and play the game, get hit, and notice that my energy/lives etc
don't go down - and soft-ice does not break in. What happens
there is that the game's code jumps over the dec instruction
which has a break point on it, thus never executing it. If you
encounter this, then it is yet another indication that the game
is using this type of weird coding.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s10">Section 10</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Once you have found the trainer data:</u></font></p>

<p>So once you have found the locations where the game keeps all
the goodies - like your live/energy/timer value, etc, make sure
you write down the location of the DEC/INC instruction, and what
memory area it decrements or increments. </p>

<p>Once you become more experienced with training, you might take
some time to study the code next to the DEC/INC instructions and
see if there are any other goodies - like making your man be
totally invincible to everything etc. </p>

<p>There are also some built-in tricks that game authors put in -
like a secret cheat mode option etc, so the work might already be
done for you. Sometimes all that it takes is the value 01 at some
memory location - and you have everything set to unlimited etc.</p>

<p>A good way of finding this sort of thing is to trace into the
decrementing routine and study the code at the start of that
routine - if they have a CMP WORD/BYTE and then a JZ to the end
of that routine, this could very well be that WORD/BYTE you have
been looking for. And if that's set, the whole routine is
bypassed and therefor there will be no decrementation of whatever
it was going to decrement. </p>

<p>Another thing you might check for, if looking for a secret
built-in trainer option in the game, is to check to see what
command line parameters the game checks for. Sometimes game
authors put in secret command line parameter options that
activate the already built-in trainers. A good example is Wing
Commander from Origin. They have a secret command line parameter
that activates the game's built-in trainer.</p>

<p>Checking to see for what command line parameters the game
checks is very easy to do with soft-ice. Simply use LDR.EXE and
load up the game's loader with some garbage parameter string. </p>

<p><strong><u>Example:</u></strong></p>

<p>LDR GAME.EXE testing</p>

<p>Now once in soft-ice, set a break point on memory range (BPM)
at DS:0082 - which points to your command line parameter
&quot;testing&quot;. Then run the program and see what your
&quot;testing&quot; string is compared to.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s11">Section 11</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Making a &quot;hard-cheat&quot;:</u></font></p>

<p>If you don't know anything about writing a loader or a tsr,
then you might consider making a &quot;hard-cheat&quot; - this
means that you simply will HEX edit the game's loader file and
search for the bytes that make up the DEC instruction(s) and nop
them out. To do this, you can use the following method:</p>

<p>Write down the HEX string that the decrementing instruction is
composed of.</p>

<p><strong><u>Example:</u></strong></p>

<p>You found this code:</p>

<p><font face="Courier">15FF C3 RET ;Returns somewhere<br>
1600 FF0E0734 DEC WORD PTR [3407] ;This is your dec<br>
1604 833E073400 CMP WORD PTR [3407],+00 ;This CMP's it <br>
1609 7415 JZ 160C ;This JMPS if Zero<br>
160B C3 RET ;Returns somewhere<br>
160C C606020301 MOV BYTE PTR [0302],01 ;This sets a byte<br>
1611 C3 RET ;Returns somewhere </font></p>

<p>Now simply note the byte composition at 1600 - FF 0E 07 34.
You might also want to take note of the following bytes (83 3E 07
34 00 74 15 C3) just to be sure you have the correct address when
you search for them.</p>

<p>Remember thou, lots of games have more than 1 DEC/INC
instruction, so it might be a good idea to search for only the
first 4 bytes that compose that decrement/increment instruction,
that way you will find them all. </p>

<p>So now you wrote down those bytes. Quit the game and use a hex
editor or debug.exe etc, and search the game's exe or com file
for those bytes. Once found, nop them out and save the file. If
you are using debug.exe to make the changes, and want to edit an
EXE file, make sure that you rename the EXE file to an extension
like DAT, prior to debugging it. This is because you can't write
to EXE/HEX files with debug.exe.</p>

<p><strong><u>Note:</u></strong></p>

<p>Look at the instruction above, at address 160C - MOVE BYTE PTR
[0302],01. Whenever the word at DS:[3407] is 0, the byte at
DS:[0302] is set to 1. What do you think this does? Here is the
advantage of studying the game's code around the DEC/INC
instructions. </p>

<p>The game will check to see if the byte at DS:0302 is 1 and
then it will display &quot;GAME OVER&quot; or something like that
- but if you nop out that MOVE BYTE PTR [0302],01 instruction,
your lives/energy/ammo/time etc will still go down, but the game
won't end or you will still have unlimited ammo etc - because, in
this example, the game checks somewhere in the program, the byte
at DS:0302, not the value of DS:3407 to make it's decision
whether to end or continue the game, etc.</p>

<p>Entering 1 byte (00) at CS:1610 as for the above example, will
not only save you 4 nops at CS:1600, but might even make you a
better trainer using a &quot;No-Touch&quot; or invincible mode
option - because the game might always &quot;think&quot; that you
are alive etc. </p>

<p>As you will see, there are many ways of training a game.</p>

<p><strong><u>Note:</u></strong></p>

<p>If you don't know how to write TSR's or loaders, then study
the interactive TSR and loader trainer examples included in this
training tutorial package.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s12a">Section 12a</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Generic trainer interfacing routine:</u></font></p>

<p>By now you should have your addresses written neatly down on a
piece of paper. What now? Next step is interfacing your trainer
with the game's code. </p>

<p>There are many ways to interface your code into the game's
code. I will show you just the best one. I have seen so many
people playing around with the timer, having their own keyboard
handling routines, hooking onto lots of unnecessary interrupts -
all this just to make a lousy 2 option &quot;trainer&quot;. Not
only does this type of programming slow down the game, but it is
much harder and longer to write up this garbage code.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s12b">Section 12b</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Interfacing to the game's keyboard routine:</u></font></p>

<p>The following routine is the routine I use in all my trainers,
and sometimes cracks. Using this method, you can interface your
code into practically any software for the PC. It is by far the
cleanest and best way to interface your trainer into the game. </p>

<p>Practically all the new games today have their own keyboard
handling routine. The method in interfacing a trainer for those
games who don't have their own keyboard handling routine, is
discussed in <a href="#s16e">section 16e</a>. </p>

<p>By now you should be still in the game. If you are not, simply
restart the game, and start playing it. Then break in with your
debugger and set a break-point on INT 9. To find the game's
keyboard handling routine using soft-ice, all you have to do is
use the command BPINT 9, re-run the program and press any key.
You should now be in the game's keyboard handling routine.</p>

<p><strong><u>Note:</u></strong></p>

<p>Make sure you write down some bytes composing the beginning of
the keyboard handling routine. You will need them to search for
that same routine again - as referred to in the example, in <a
href="#s14">section 14</a>.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s12c">Section 12c</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Finding the game's keyboard handling
routine:</u></font></p>

<p>The game usually saves the original INT 9 vector address and
then redefines the INT 9 vector address to point to it's keyboard
handling routine. So when you start debugging the game, trace it
all the way until you notice the INT 9 vector being redirected to
another location. This is the location that I'm referring to.</p>

<p>If you have problems finding the routine in the game's program
code which redirects INT 9, then you can do the following:</p>

<p>Start and play the game, then break in with your debugger and
view the INT 9 vector address currently in the vector table (at
0000:0022).</p>

<p><strong><u>Example:</u></strong></p>

<p>After you dumped 0000:0022 you see the following:</p>

<p><font face="Courier">0000:0022 1F 10 20 AC XX XX XX XX XX XX
XX XX XX XX XX XX<br>
A B :C D</font></p>

<p>Your main concern is with the first 4 bytes. I have named them
A,B,C,D. Now to find out where the game's keyboard handling
routine points to, simply view it this way:</p>

<p>BA:DC - now replace each letter with the value it stands for:</p>

<p>101F:AC20 - simple ey! - so if you set a break point on this
address, and then press any key, you will be right in the game's
keyboard routine.</p>

<p>Once you set a break point on INT 9 or at the beginning of the
keyboard handling routine, run the game, and press any key. Your
debugger should break in. Now study the code. Below, in section
12d, is an example of the beginning of a typical keyboard
handling routine (taken from Prince of Persia II).</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s12d">Section 12d</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Prince of Persia II keyboard handling
routine listing:</u></font></p>

<p><font face="Courier">165D 1E PUSH DS ;Save current DS<br>
165E 50 PUSH AX ;Save current AX<br>
165F 53 PUSH BX ;Save current BX<br>
1660 B8C03F MOV AX,3FC0 ;Move data-area value into AX<br>
1663 8ED8 MOV DS,AX ;Move AX to DS<br>
1665 E460 IN AL,60 ;*** Read keyboard port ***<br>
1667 8AD8 MOV BL,AL ;Move read value in AL to BL<br>
1669 D0C0 ROL AL,1 ;etc<br>
166B 2401 AND AL,01 ;etc</font></p>

<p>Most keyboard handling routines have the same structure as the
above. Note the instruction at 1660 - MOV AX,3FC0 - this is the
games data segment address. This value is then moved to DS. Lots
of games use this technique. </p>

<p>The above technique helps us a lot because your trainer
doesn't always have to find out what the game's current DS value
is. This instruction is nearly always present in the keyboard
handling routines of most games.</p>

<p>The reason for this is as follows. Whenever you press a key in
the game, the game's current DS can be anything - because INT 9
will interrupt the current operation of the program and execute
the keyboard handling routine, - with the DS value being whatever
it was just before the INT 9 was called. That is why the program
has to reset the current DS address with the<br>
predetermined DS address where it always keeps the key press
values.</p>

<p>Most often, the DS address value used in the keyboard handling
routine, is the SAME as the DS address value for which the game
uses to store it's lives/energy/ammo etc values. - Sometimes this
is not so. (Read &quot;Handling different DS values&quot;,
outlined in section 13 for explanations how to cope when the
game's keyboard handling routine's DS value is different from the
DS value where the game keeps the energy/lives/ammo etc, values).</p>

<p>Once you have found the game's keyboard handling routine, your
main concern is the address where the keyboard port is read in -
with the instruction IN AL,60. Put a break point on that address
and run the game. Press any key now and you should be in the
debugger. Write down the current IP where the IN AL,60
instruction is. (You will need that IP value later on when
writing the trainer interfacing routine).</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s13">Section 13</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Handling different DS values:</u></font></p>

<p>Remember that the DS that the keyboard handling routine uses
to store it's data is not always the same DS that the game keeps
the lives/energy/ammo/timer etc values at. If the DS value in the
keyboard handling routine is different from the DS value where
the game keeps your lives/energy etc values, then you will have
to do the following:</p>

<p>Write down the DS value that the keyboard handling routine
uses and the DS value that the game uses to store your
lives/energy/ammo/timer etc values. Quit the program and
calculate how much to add or subtract from the keyboard routine's
DS value, to obtain the DS value that the game uses to store it's
lives/energy etc, values at. I use debug.exe to do the
calculations.</p>

<p><strong><u>Example:</u></strong></p>

<p>DS in the keyboard handling routine is 2CF0. The DS value
where the game keeps your lives/energy etc values is 1345 (which
is lower than 2CF0, so you will subtract it from 2CF0).</p>

<p>Using debug.exe:</p>

<p><font face="Courier">A 100<br>
XXXX:0100 MOV AX,2CF0<br>
XXXX:0104 SUB AX,1345</font></p>

<p>Now simply proceed through those 2 instructions and note the
AX value after the SUB instruction. Write it down. In this
example the value of AX after subtraction is 19AB. So in your
loader/tsr code you could do the following:</p>

<p>PUSH AX ;Save current AX value<br>
PUSH DS ;Save current DS value<br>
MOV AX,19AB ;Move 19AB to AX (the calculated value as shown
above)<br>
SUB DS,AX ;Subtract the game's current keyboard DS value with the
calculated AX value. Now DS will equal the DS value where the
game keeps the lives/energy etc values at. </p>

<p>Remember also that you don't necessary have to use DS always -
the game can be using CS to store your current lives/energy etc
values - if so, simply modify the above routine to work with CS.
The above trick works for every possible address, so you will
always find your data.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s14">Section 14</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Writing the trainer loader or TSR code:</u></font></p>

<p>By now you should have all the training-related information on
paper. It should include:</p>

<p>1) The addresses where the lives/energy etc are stored
(XXXX:YYYY) - (not the actual DEC/INC instruction address
locations, but the addresses that the DEC/INC instructions
modify). </p>

<p>2) The value to add/decrement to/from the above addresses. (If
you want to increase your energy, for example, to full, note what
value represents energy full at that address, so when you later
on define the trainer keys, and select the energy-boost key, you
will know what value to add to the energy storage address to
boost up the energy to max). </p>

<p>3) The address of the program's keyboard handling routine and
the IP of the IN AL,60 instruction. (If there is no IN AL,60
instruction in the keyboard handling routine, then write down the
address of the IP of your chosen instruction to replace with CD
21 - for more information refer to &quot;Interfacing with
different keyboard handling routines&quot;, outlined in <a
href="#s16e">section 16e</a>).</p>

<p>You should have 2 addresses of the program's keyboard handling
routine. The first one should be the address that you
check/interface your trainer code into the game's keyboard
handling routine. </p>

<p>To get this address, start up your debugger, debug the game's
loader and set a break point on INT 21 - if using soft-ice, or
trace the program to the first INT 21. Then once you are there,
don't trace into the INT 21, just merely search for the keyboard
handling routine using the program's current CS. (You should have
previously noted some of the bytes which compose the beginning of
the keyboard handling routine. Refer to the &quot;Note&quot;,
back in <a href="#s12b">section 12b</a>). </p>

<p><strong><u>Example:</u></strong></p>

<p>You are looking for the following bytes : E4 60 8A D8 D0 C0 </p>

<p>S CS:0 L FFFF E4 60 8A D8 D0 C0 </p>

<p>If you find nothing, try DS, ES, or SS. If you still find
nothing, then search higher in memory like 2000, 3000, 4000 etc.
(Refer to <a href="#s9">section 9</a> for more information on
searching for data).</p>

<p>If you still don't find those bytes, then the keyboard
handling routine in the program might still be compressed or
encrypted. Run the program for a bit and then retry the above
steps.</p>

<p><strong><u>Note:</u></strong></p>

<p>If you didn't find the routine while searching with CS, DS,
ES, or SS, but found it when you searched the higher memory, like
3000 for example, then you will have to do either one of the
following:</p>

<p>3a) Set a break point on the next INT 21, or run the game for
a bit, then reset the break point back to INT 21. Then try again
to search for the keyboard routine's bytes - only using CS, DS,
ES, or SS. If you still don't find anything, then resort to step
3b.</p>

<p>3b) Since the keyboard handling routine address cannot be
found using the current CS, DS, ES or SS, you won't be able to
interface your trainer code using the above registers. You will
have to use the method described in <a href="#s13">section 13</a>,
and use the memory range address at which you DID manage to find
the keyboard handling routine with (eg: 0800:XXXX or 3000:XXXX
etc). </p>

<p>The second address should be the game's current CS:IP when the
game is running. (For more information, refer to &quot;Finding
the runtime CS:IP of the keyboard handling routine&quot;,
outlined in <a href="#s16c">section 16c</a>).</p>

<p><strong><u>Note:</u></strong></p>

<p>The 2 addresses described above, can be the same - the game's
CS can be the same at startup and once it's running, but if it's
not, then follow the above steps to obtain those 2 addresses. You
will need them later on to write the generic trainer code
interfacing routine, as outlined in <a href="#s16a">section 16a</a>.
</p>

<p>4) If the DS value in the program's keyboard handling routine
is different from the address where the game keeps the
lives/energy etc values, as outlined in <a href="#s13">section 13</a>,
you should have both the program's keyboard handling routine's DS
value and the address (XXXX:YYYY) where the program keeps the
lives/energy etc values at.</p>

<p>(You should also have calculated out what the final DS value
should be for the above. (For more information refer to
&quot;Handling different DS values&quot;, outlined in <a
href="#s13">section 13</a>)).</p>

<p>5) The keyboard key press scan value that you will compare
later on in your trainer code, for your defined trainer keys. </p>

<p>Once you have necessary information as stated above, then you
are ready for the next step.</p>

<p>The loader or TSR that you are going to use has to be able to
hook onto an existing interrupt and redefine it's vector to your
trainer routine. I usually hook onto INT 21, but in theory you
can hook onto any interrupt you wish. But hooking onto INT 21 is
preferable because of 2 things:</p>

<p>1) All the games will use INT 21 at some point in the game -
therefor activating your defined INT 21 routine, which in turn
integrates itself directly to the game's code.</p>

<p>2) There won't be much &quot;confusion&quot; once the game is
running. - Games very seldomly execute INT 21's during game play
- so your INT 21 &quot;interface&quot; will not
slow-down/conflict with any game playing operations. </p>

<p>Also loader-trainers are better than writing TSR-trainers
mainly because they are &quot;cleaner&quot; - sure they both hook
onto certain interrupts, but a loader always restores it's hooked
interrupt(s) upon exiting the program, and in most cases, uses
less memory. </p>

<p>If you don't know how to write loaders, or prefer to write
TSR's, then I suggest that you also include a self-removal option
in your TSR - either user requested or upon program termination.
You can use the routine outlined in section 15.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s15">Section 15</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Generic TSR self-removal routine:</u></font></p>

<p><font face="Courier">0100 1E PUSH DS <br>
0101 50 PUSH AX <br>
0102 52 PUSH DX <br>
0103 06 PUSH ES <br>
0104 0E PUSH CS <br>
0105 1F POP DS <br>
0106 A12C00 MOV AX,[002C]</font></p>

<p>0106 : Get the DOS environment segment address.</p>

<p><font face="Courier">0109 8EC0 MOV ES,AX <br>
010B B449 MOV AH,49 <br>
010D CD21 INT 21</font></p>

<p>010D : Free the allocated memory.</p>

<p><font face="Courier">010F C5167801 LDS DX,[0200]</font></p>

<p>010F : Load pointer using DS - from DS:[0200] (DS=CS). This is
done to restore the original INT 21 vector. The original vector
was saved at CS:0200.</p>

<p><font face="Courier">0113 B82125 MOV AX,2521 <br>
0116 CD21 INT 21</font></p>

<p>0116 : Hook and restore back the original INT 21 vector.</p>

<p>The below routine removes the TSR from the memory block:</p>

<p><font face="Courier">0118 8CC8 MOV AX,CS<br>
011A 48 DEC AX<br>
011B 8ED8 MOV DS,AX<br>
011D C70601000000 MOV WORD PTR [0001],0000<br>
0123 07 POP ES<br>
0124 5A POP DX<br>
0125 58 POP AX<br>
0126 1F POP DS<br>
0127 CF IRET</font></p>

<p>0200 0000 0000 ;Original INT 21 vector saved here</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s16a">Section 16a</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Generic trainer code interfacing routine:</u></font></p>

<p>The way this routine works is by hooking itself to the game's
code, mainly at the address where the IN AL,60 - keyboard port
read instruction is. It replaces the original bytes of that
instruction (E4 60) with CD 21. Every time you press any key
during the game, your trainer routine is executed
instantaneously.</p>

<p>I will take you step by step through the next example, taken
from the Interactive 8 option trainer for Prince of Persia II.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s16b">Section 16b</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Prince of Persia II interactive trainer
interfacing routine:</u></font></p>

<p><font face="Courier">0100 9C PUSHF ;Push Flag<br>
0101 55 PUSH BP ;Push BP<br>
0102 1E PUSH DS ;Push DS<br>
0103 89E5 MOV BP,SP ;Move current SP to BP<br>
0105 8E5E08 MOV DS,[BP+08] ;Move current CS to DS.</font></p>

<p>The principle of operation of the 0105 instruction is as
follows. </p>

<p>Whenever an interrupt is called, the original FLAGS, CS, and
IP are pushed into the stack. Now if you move the current SP to
BP, then move the value at SS:[BP+08] to DS, you will get the
program's current CS.</p>

<p><font face="Courier">0108 26 ES:<br>
0109 813E6516E460 CMP WORD PTR [1665],60E4</font></p>

<p>0109 : Compare the values at address ES:1665 to 60 E4.</p>

<p>Why ES:? Remember that your trainer routine is hooked onto INT
21. Now whenever the game starts up - the very first INT 21
executed, will either be the dos version checking INT 21, or a
memory allocating INT 21 etc.</p>

<p>Now every time ANY INT 21 is executed in the game, if the
current CS:IP is let's say at 2300:1200, and the keyboard
handling routine's IN AL,60 address is at 14FA:0377, then you
won't be able to interface your code to the keyboard handling
routine's code, since the program's current CS is way higher than
14FA. </p>

<p>The reason I used the ES value is because the value was just
perfect - I found the E4 60 bytes at address 1665 when searching
with ES:, but couldn't find them when searching with CS, DS, or
SS. (You see, it's a good idea to search with DS, ES, or SS first
- if unable to find anything using CS, before adverting to the
procedures outlined in <a href="#s13">section 13</a>).</p>

<p>But in most cases you will be able to interface directly to
the game's keyboard handling routine with the program's current
CS value. (For more information, refer to step 3 in &quot;Writing
the trainer loader or tsr&quot;, outlined in <a href="#s14">section
14</a>).</p>

<p>0109 : The instruction at 0109 is checking if at ES:1665 the
bytes E4 60 exist - if they do, it means that's where the
instruction IN AL,60 is. (Refer to &quot;Prince of Persia II
keyboard handling routine listing&quot;, outlined in <a
href="#s12d">section 12d</a>).</p>

<p>010F 7507 JNZ 0118 ; If it is not, then jump to the exit
portion of your routine.</p>

<p><font face="Courier">0111 26 ES: <br>
0112 C7066516CD21 MOV WORD PTR [1665],21CD</font></p>

<p>0112 : Else, replace the instruction at ES:1665 with CD 21
(your already hooked INT 21 handling routine).</p>

<p><font face="Courier">0118 817E066715 CMP WORD PTR [BP+06],1567<br>
011D 7405 JZ 0124</font></p>

<p>0118 : Compare if SS:BP+06 (which is the game's current IP
BEFORE it entered your INT 21 hooked routine) to 1567. This
routine is comparing if the INT 21 instruction is YOURS or if
it's some other INT 21 instruction used by the game. This is
accomplished by comparing the game's current IP (instruction
pointer) to 1567. If it is indeed YOUR inserted INT 21 routine
calling, then the trainer JMPS to it's trainer routine (which
starts here at 0124).</p>

<p>In this example, you will notice that the IP is different from
the address 1665 - it's 1567. Why? Simple, because when the game
runs, the CS was different from ES - which you previously used to
insert the CD 21 with. (For more information regarding the IP,
refer to <a href="#s16c">section 16c</a>).</p>

<p>The routine below, restores DS,BP,FLAGS and jumps to the
original INT 21 vector:</p>

<p><font face="Courier">011F 1F POP DS <br>
0120 5D POP BP <br>
0121 9D POPF <br>
0122 EB77 JMP 019B</font></p>

<p>The above routine is executed due to one of the following:</p>

<p>1) Either the E4 60 value was not found at the specified
address or;</p>

<p>2) The program's current IP is not pointing to your inserted
INT 21 IP address. (This might be another INT 21 instruction that
the game is currently using somewhere else - so the trainer code
will restore DS, BP and the FLAGS, and jump to the original INT
21 saved vector, thus letting the game do whatever it wanted to. </p>

<p>Else, the following code is executed:</p>

<p><font face="Courier">0124 1F POP DS</font></p>

<p>0124 : Restore the program's current DS. In this case the
keyboard handling routine's DS value is the same for where the
game keeps it's key presses and where it stores the value of your
current energy/time/level etc, values. That's why I restored DS
right here, so my trainer can use it later on. (And also note
that for this trainer example, you don't need to use the
procedures listed in &quot;Handling different DS values&quot;, as
outlined in <a href="#s13">section 13</a>) </p>

<p><font face="Courier">0125 E460 IN AL,60</font></p>

<p>0125 : This instruction reads the keyboard port. This
instruction has to be present in the trainer code, since you
replaced it with CD 21 in the game's code, remember?</p>

<p>The following code compares the key press to the function keys
defined for the trainer, and jumps correspondingly:</p>

<p><font face="Courier">0127 3C3B CMP AL,3B<br>
0129 741F JZ 014A<br>
012B 3C3C CMP AL,3C<br>
012D 7422 JZ 0151<br>
012F 3C3D CMP AL,3D<br>
0131 745D JZ 0190<br>
0133 3C3E CMP AL,3E<br>
0135 7421 JZ 0158<br>
0137 3C3F CMP AL,3F<br>
0139 7433 JZ 016E<br>
013B 3C40 CMP AL,40<br>
013D 7436 JZ 0175<br>
013F 3C43 CMP AL,43<br>
0141 743D JZ 0180<br>
0143 3C44 CMP AL,44<br>
0145 7441 JZ 0188</font></p>

<p>If some other key was pressed, which is not used by the
defined trainer keys, the following routine is executed. It
merely restores the BP, FLAGS and IRETS back to the program. The
AX value however was not saved in the beginning of the routine,
and is always different upon returning back to the program.
There, it is used by the game to determine what keys were
pressed. (The original DS value was restored earlier remember?).</p>

<p><font face="Courier">0147 5D POP BP<br>
0148 9D POPF<br>
0149 CF IRET</font></p>

<p>The following instructions change the data values in the
program's DS to train the game. The trainer data was derived
using the same techniques as outlined in this training tutorial.</p>

<p><font face="Courier">014A C606865C01 MOV BYTE PTR [5C86],01<br>
014F EBF6 JMP 0147<br>
0151 C606865C00 MOV BYTE PTR [5C86],00<br>
0156 EBF7 JMP 014F<br>
0158 C6060D5C21 MOV BYTE PTR [5C0D],21<br>
015D C6064D5C21 MOV BYTE PTR [5C4D],21<br>
0162 C606CD5C21 MOV BYTE PTR [5CCD],21<br>
0167 C6060D5D21 MOV BYTE PTR [5D0D],21<br>
016C EBE8 JMP 0156<br>
016E C6062A5EFF MOV BYTE PTR [5E2A],FF<br>
0173 EBF7 JMP 016C<br>
0175 C6062C5E01 MOV BYTE PTR [5E2C],01<br>
017A FE06465E INC BYTE PTR [5E46]<br>
017E EBF3 JMP 0173<br>
0180 C706825C9300 MOV WORD PTR [5C82],0093<br>
0186 EBF6 JMP 017E<br>
0188 C706825CC101 MOV WORD PTR [5C82],01C1<br>
018E EBF6 JMP 0186<br>
0190 C706925C1919 MOV WORD PTR [5C92],1919<br>
0196 EBF6 JMP 018E<br>
0198 90 NOP <br>
0199 90 NOP <br>
019A 90 NOP <br>
019B EA00000000 JMP XXXX:XXXX ;Jump back to the original INT
21vector.</font></p>

<p>For a better understanding of the above code, study the Prince
of Persia II interactive 8 option TSR or loader trainer examples
(PP2T-TSR.COM and PP2T-LDR.COM and their DOC - PP2T-T&amp;L.DOC).
Both are included in this training tutorial package. They
correspond exactly to the above example.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s16c">Section 16c</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Finding the runtime CS:IP of the keyboard
handling routine:</u></font></p>

<p>To always know what the current IP will be once the program is
running, simply set a break point in the program's keyboard
handling routine, press a key, and once your debugger breaks in,
note the address of the keyboard handling routine. Write down the
address of the IN AL,60 instruction. If the game doesn't use INT
9 or IN AL,60 in it's keyboard handling routine, then refer to
&quot;Interfacing with different keyboard handling
routines&quot;, as outlined in <a href="#s16e">section 16e</a>).</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s16d">Section 16d</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Comparing the program's current IP:</u></font></p>

<p>When comparing the program's current IP - like in the above
example in <a href="#s16b">section 16b</a>, at 0118, you have to
remember that the program's current IP points to the address
AFTER the interrupt was called.</p>

<p><strong><u>Example:</u></strong></p>

<p>If the code looks like this:</p>

<p><font face="Courier">0100 E460 IN AL,60<br>
0102 88C3 MOV BL,AL</font></p>

<p>And you replace E4 60 with CD 21:</p>

<p><font face="Courier">0100 CD21 INT 21 <br>
0102 88C3 MOV BL,AL </font></p>

<p>Then once the program executes your interrupt 21, and you
check for the program's current IP as described above, make sure
you compare the IP to 0102! - the instruction right after the INT
21 - because after all, once the program exits from your INT 21
routine via the IRET instruction, it doesn't return back to 0100,
it returns to the next following instruction.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s16e">Section 16e</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Interfacing with different keyboard handling
routines:</u></font></p>

<p>All games have a keyboard handling routine. But some rare OLD
games might not use INT 9 to handle their key presses, or they
might not use the IN AL,60 instruction - just INT 16 for checking
key presses. </p>

<p>So what's the problem there? Again, simply find a 2 byte
instruction somewhere right after the INT 16 instruction that you
can replace with CD 21, and you are in business.</p>

<p><strong><u>Example:</u></strong></p>

<p><font face="Courier">0100 30E4 XOR AH,AH<br>
0102 CD16 INT 16 ;here is the game's INT 16<br>
0104 88C3 MOV BL,AL <br>
0106 80EB11 SUB BL,11 </font></p>

<p>There is a nice instruction at 0104 that you can change to CD
21. Then all you have to do in your INT 21 hooked routine is to
execute that instruction somewhere in the beginning or the end of
your code - doesn't really matter where, but make sure BL equals
the AL key press value, once your routine IRETS back to 0106.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s17">Section 17</a></td>
    </tr>
</table>
</center></div>

<p>Below is another example, taken from the Fox Ranger
interactive 9 option trainer. Notice that at 010A, there is no E4
60 (IN AL,60). I'm hooking INT 21 at some address which is in the
game's program loop - you see, it can be done in lots of
different ways, as described above in &quot;Interfacing with
different keyboard handling routines&quot;, in <a href="#s16e">section
16e</a>. I will only explain the important stuff in the following
example:</p>

<p><font size="4"><u>Fox Ranger interactive 9 option trainer
routine listing:</u></font></p>

<p><font face="Courier">0100 9C PUSHF<br>
0101 55 PUSH BP<br>
0102 1E PUSH DS<br>
0103 89E5 MOV BP,SP<br>
0105 8E5E08 MOV DS,[BP+08]<br>
0108 26 ES:<br>
0109 813EBA1DB000 CMP WORD PTR [1DBA],00B0<br>
010F 7507 JNZ 0118</font></p>

<p>0109 : Compare ES:[1DBA] to 00 B0, if not, restore DS,BP,FLAGS
and jump to the original INT 21 vector.</p>

<p><font face="Courier">0111 26 ES:<br>
0112 C706BA1DCD21 MOV WORD PTR [1DBA],21CD</font></p>

<p>0112 : Hook your defined INT 21 routine at ES:[1DBA]</p>

<p><font face="Courier">0118 817E06BC1C CMP WORD PTR [BP+06],1CBC<br>
011D 7405 JZ 0124</font></p>

<p>0118 : Compare current SS:[BP+06] (BP=SP) which is the
program's current IP to 1CBC - if it's at your INT 21 IP, then
jmp to the trainer routine, else restore DS,BP,FLAGS and jump to
the original INT 21 vector (as in 011F-0122).</p>

<p><font face="Courier">011F 1F POP DS<br>
0120 5D POP BP<br>
0121 9D POPF<br>
0122 EB7D JMP 01A1<br>
0124 8CDD MOV BP,DS<br>
0126 06 PUSH ES<br>
0127 1F POP DS<br>
0128 A0722D MOV AL,[2D72]</font></p>

<p>0128 : Move into AL the key press which the game stored at
ES:[2D72] - (As you see, the game does not always have to have
the IN AL,60 instruction, for you to be able to interface your
trainer with the keyboard. As long as you find out where the game
stores it's key presses, you will always be in business.</p>

<p>The following compares the key press to see if it's one of the
defined trainer key presses:</p>

<p><font face="Courier">012B 3C4A CMP AL,4A<br>
012D 7459 JZ 0188<br>
012F 3C4E CMP AL,4E<br>
0131 744B JZ 017E<br>
0133 3C26 CMP AL,26<br>
0135 7461 JZ 0198<br>
0137 3C30 CMP AL,30<br>
0139 7427 JZ 0162<br>
013B 3C20 CMP AL,20<br>
013D 742A JZ 0169<br>
013F 3C32 CMP AL,32<br>
0141 7412 JZ 0155<br>
0143 3C21 CMP AL,21<br>
0145 744B JZ 0192<br>
0147 3C24 CMP AL,24<br>
0149 7425 JZ 0170<br>
014B 3C1E CMP AL,1E<br>
014D 7428 JZ 0177<br>
014F B000 MOV AL,00<br>
0151 1F POP DS<br>
0152 5D POP BP<br>
0153 9D POPF<br>
0154 CF IRET</font></p>

<p>The following is the training routine. The training data was
derived using the same techniques as outlined in this training
tutorial.</p>

<p><font face="Courier">0155 A2802F MOV [2F80],AL<br>
0158 893E812F MOV [2F81],DI<br>
015C 893E832F MOV [2F83],DI<br>
0160 EBED JMP 014F<br>
0162 C606BF2F01 MOV BYTE PTR [2FBF],01<br>
0167 EBF7 JMP 0160<br>
0169 C6067A2F01 MOV BYTE PTR [2F7A],01<br>
016E EBF7 JMP 0167<br>
0170 C606244305 MOV BYTE PTR [4324],05<br>
0175 EBF7 JMP 016E<br>
0177 C6067E2F01 MOV BYTE PTR [2F7E],01<br>
017C EBF7 JMP 0175<br>
017E 8EDD MOV DS,BP<br>
0180 C70660DD0900 MOV WORD PTR [DD60],0009<br>
0186 EBF4 JMP 017C<br>
0188 8EDD MOV DS,BP<br>
018A C70660DDB304 MOV WORD PTR [DD60],04B3<br>
0190 EBF4 JMP 0186<br>
0192 FE06792F INC BYTE PTR [2F79]<br>
0196 EBF8 JMP 0190<br>
0198 FE06762F INC BYTE PTR [2F76]<br>
019C EBF8 JMP 0196<br>
019E 90 NOP<br>
019F 90 NOP<br>
01A0 90 NOP<br>
01A1 EA00000000 JMP XXXX:XXXX ; Jump back to the original INT 21
vector.</font></p>

<p>For a better understanding, study the Fox Ranger interactive 9
option tsr trainer example (FRT-TSR.COM and read it's DOC -
FRT-TSR.DOC) included in this trainer package. It corresponds
exactly to the above example.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s18">Section 18</a></td>
    </tr>
</table>
</center></div>

<p>Below is another example, taken from the Legend of Myra
Interactive 10 option trainer:</p>

<p><font size="4"><u>Legend of Myra Interactive 10 option trainer
routine listing:</u></font></p>

<p><font face="Courier">0100 9C PUSHF <br>
0101 55 PUSH BP <br>
0102 1E PUSH DS <br>
0103 89E5 MOV BP,SP<br>
0105 8E5E08 MOV DS,[BP+08]<br>
0108 813E250E8AD8 CMP WORD PTR [0E25],D88A<br>
010E 7506 JNZ 0116</font></p>

<p>0108 : Compare the word at CS:[0E25] (DS=CS because of the
instruction at 105) to D8 8A. Skip the following instruction if
not zero.</p>

<p><font face="Courier">0110 C706250ECD21 MOV WORD PTR
[0E25],21CD</font></p>

<p>0110 : Interface your INT 21 hooked routine at CS:[0E25]</p>

<p><font face="Courier">0116 817E06270E CMP WORD PTR [BP+06],0E27<br>
011B 7406 JZ 0123</font></p>

<p>0116 : Compare the word at SS:[BP+06] (which is the program's
current IP) to 0E27. Note that the address of the program's
current IP and the address where you inserted your CD 21 word is
identical - you see, sometimes the program's current CS can be
the same at startup, and during game play. (Refer to step 3 in
&quot;Writing the trainer loader or tsr code&quot;, outlined in <a
href="#s14">section 14</a>).</p>

<p>(The reason for the 2 byte increase from 0E25 to 0E27 now, is
because the program's current IP points to the next following
instruction after your INT 21. (For more information on this,
refer to &quot;Comparing the program's current IP&quot;, outlined
in <a href="#s16d">section 16d</a>).</p>

<p>The next instructions listed below restore DS,BP,FLAGS and
jump back to the original INT 21 vector - if the compare at
either 0108 or 0116 failed.</p>

<p><font face="Courier">011D 1F POP DS <br>
011E 5D POP BP <br>
011F 9D POPF <br>
0120 E97F00 JMP 01A2</font></p>

<p>The instructions below move into AL the key presses taken from
the program's keyboard key press storage data area and compare
them to the trainer defined keys:</p>

<p><font face="Courier">0123 1F POP DS <br>
0124 5D POP BP <br>
0125 50 PUSH AX <br>
0126 A0E409 MOV AL,[09E4]<br>
0129 3C3B CMP AL,3B<br>
012B 743B JZ 0168<br>
012D 3C3C CMP AL,3C<br>
012F 743D JZ 016E<br>
0131 3C3D CMP AL,3D<br>
0133 7427 JZ 015C<br>
0135 3C3E CMP AL,3E<br>
0137 743B JZ 0174<br>
0139 3C3F CMP AL,3F<br>
013B 7425 JZ 0162<br>
013D 3C40 CMP AL,40<br>
013F 7415 JZ 0156<br>
0141 3C41 CMP AL,41<br>
0143 7435 JZ 017A<br>
0145 3C42 CMP AL,42<br>
0147 7437 JZ 0180<br>
0149 3C43 CMP AL,43<br>
014B 7440 JZ 018D<br>
014D 3C44 CMP AL,44<br>
014F 7435 JZ 0186<br>
0151 58 POP AX <br>
0152 9D POPF <br>
0153 EB44 JMP 0199<br>
0155 90 NOP</font></p>

<p>The following is the training routine. The training data was
derived using the same techniques as outlined in this training
tutorial. </p>

<p><font face="Courier">0156 C646F643 MOV BYTE PTR [BP-0A],43<br>
015A EB38 JMP 0194<br>
015C C646F6CE MOV BYTE PTR [BP-0A],CE<br>
0160 EB32 JMP 0194<br>
0162 C646F65E MOV BYTE PTR [BP-0A],5E<br>
0166 EB2C JMP 0194<br>
0168 C646F691 MOV BYTE PTR [BP-0A],91<br>
016C EB26 JMP 0194<br>
016E C646F693 MOV BYTE PTR [BP-0A],93<br>
0172 EB20 JMP 0194<br>
0174 C646F6CD MOV BYTE PTR [BP-0A],CD<br>
0178 EB1A JMP 0194<br>
017A C646F6C3 MOV BYTE PTR [BP-0A],C3<br>
017E EB14 JMP 0194<br>
0180 FE06EE1F INC BYTE PTR [1FEE]<br>
0184 EBCB JMP 0151<br>
0186 C606FD3D01 MOV BYTE PTR [3DFD],01<br>
018B EBC4 JMP 0151<br>
018D C606D01F64 MOV BYTE PTR [1FD0],64<br>
0192 EBBD JMP 0151<br>
0194 58 POP AX <br>
0195 31C0 XOR AX,AX<br>
0197 EBB9 JMP 0152<br>
0199 C606E40900 MOV BYTE PTR [09E4],00<br>
019E 88C3 MOV BL,AL<br>
01A0 CF IRET <br>
01A1 90 NOP <br>
01A2 EA00000000 JMP XXXX:XXXX ;Jump back to the original INT 21<br>
vector.</font></p>

<p>For a better understanding, study the Legend of Myra
interactive 10 option tsr trainer example (LOMT-TSR.COM and read
it's DOC - LOMT-TSR.DOC) included in this training package. It
corresponds exactly with the above example.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s19">Section 19</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Interactive TSR/loader trainer examples:</u></font></p>

<p>This training tutorial comes with 4 interactive trainer
examples (in COM format) There are 3 interactive TSR trainer
examples and 1 interactive trainer loader example, included with
this training tutorial. The ASM code structure of all 4
interactive trainer examples, is identical to the ASM code
structure of the examples outlined in this documentation. Even
the trainer code found in each of the 4 trainer examples, starts
at CS:0100 - exactly as listed here in this training tutorial.</p>

<p>This was done so that you will be able to study the examples
listed here and then refer to the actual interactive TSR/loader
trainer examples.</p>

<p>You should note however, that all the 3 TSR trainers use the
same install checking routine - to see if they have already been
previously installed in memory. Remember to only install one at a
time.</p>

<hr>
<div align="center"><center>

<table border="2" bgcolor="#008080" bordercolordark="#000000"
bordercolorlight="#A3A3A3">
    <tr>
        <td><a name="s20">Section 20</a></td>
    </tr>
</table>
</center></div>

<p><font size="4"><u>Summary:</u></font></p>

<p>By studying the above examples and the actual trainer program
examples (PP2T-TSR.COM, FRT-TSR.COM, LOMT-TSR.COM, PP2T-LDR.COM)
included in this <a href="TT-UNT.ZIP">trainer tutorial package</a>,
you will learn how to write trainers for the PC, or at least
broaden your knowledge on this topic.</p>

<p>I hope this trainer tutorial helps all you boys out there who
always wondered how it's done. Maybe now I can retire for good
since you boys will be making all the trainers from now on! </p>

<p>Anyways...</p>

<p>From the boys at UNT, : Take care &amp; have PHUN!</p>

<p>Dr. Detergent / UNT'93</p>

<hr>

<p><font size="2">Converted to HTML by Jammer/HBD</font></p>
</body>
</html>
